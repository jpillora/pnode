// Generated by CoffeeScript 1.6.3
var Base, Client, Connection, LocalPeer, ObjectIndex, RemotePeer, Server, helper, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('../../vendor/lodash');

Server = require('../server/server');

Connection = require('../server/connection');

Client = require('../client/client');

Base = require('../base');

helper = require('../helper');

RemotePeer = require('./remote-peer');

ObjectIndex = require('object-index');

module.exports = LocalPeer = (function(_super) {
  __extends(LocalPeer, _super);

  LocalPeer.prototype.name = 'LocalPeer';

  LocalPeer.prototype.defaults = {
    debug: false,
    wait: 1000,
    learn: false
  };

  function LocalPeer() {
    var _this = this;
    LocalPeer.__super__.constructor.apply(this, arguments);
    this.servers = {};
    this.peers = ObjectIndex("id", "guid");
    if (this.opts.learn) {
      this.expose({
        _pnode: {
          serialize: this.exposeDynamic(function() {
            return _this.serialize();
          })
        }
      });
    }
  }

  LocalPeer.prototype.bindOn = function() {
    var server,
      _this = this;
    server = new Server(this);
    server.on('error', function(err) {
      return _this.emit('error', err);
    });
    server.on('connection', this.onPeer);
    server.bindOn.apply(server, arguments);
    this.servers[server.guid] = server;
    return server.once('unbind', function() {
      return delete _this.servers[server.guid];
    });
  };

  LocalPeer.prototype.bindTo = function() {
    var client,
      _this = this;
    client = new Client(this);
    client.on('error', function(err) {
      return _this.emit('error', err);
    });
    client.on('remote', function() {
      return _this.onPeer(client);
    });
    return client.bindTo.apply(client, arguments);
  };

  LocalPeer.prototype.unbind = function() {
    var guid, peer, server, _i, _len, _ref, _ref1, _results;
    this.log("UNBIND SELF AND ALL PEERS");
    _ref = this.peers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      peer = _ref[_i];
      peer.unbind();
    }
    _ref1 = this.servers;
    _results = [];
    for (guid in _ref1) {
      server = _ref1[guid];
      _results.push(server.unbind());
    }
    return _results;
  };

  LocalPeer.prototype.onPeer = function(cliconn) {
    var guid, id, ips, peer, remote, _ref,
      _this = this;
    if (!(cliconn instanceof Client || cliconn instanceof Connection)) {
      return this.log("must be client or conn");
    }
    remote = cliconn.remote;
    if (!remote) {
      return this.log('peer missing remote');
    }
    _ref = remote._pnode, guid = _ref.guid, id = _ref.id, ips = _ref.ips;
    if (!guid) {
      return this.log('peer missing guid');
    }
    peer = this.peers.get(guid);
    if (!peer) {
      peer = new RemotePeer(this, guid, id, ips);
      this.peers.add(peer);
      peer.on('up', function(remote) {
        _this.emit('peer', peer);
        return _this.emit('remote', remote);
      });
      peer.on('down', function() {
        return _this.log("lost peer %s", guid);
      });
    }
    peer.add(cliconn);
  };

  LocalPeer.prototype.serialize = function() {
    return {
      servers: helper.serialize(this.servers),
      peers: helper.serialize(this.peers.list)
    };
  };

  LocalPeer.prototype.all = function(callback) {
    var guid, peer, rems, _ref;
    rems = [];
    _ref = this.peers;
    for (guid in _ref) {
      peer = _ref[guid];
      if (peer.up) {
        rems.push(peer.remote);
      }
    }
    return callback(rems);
  };

  LocalPeer.prototype.peer = function(id, callback) {
    var check, get, t,
      _this = this;
    get = function() {
      var peer;
      _this.log("get " + id);
      peer = _this.peers.get(id);
      if (!(peer != null ? peer.up : void 0)) {
        return false;
      }
      callback(peer.remote);
      return true;
    };
    if (get()) {
      return;
    }
    check = function() {
      if (!get()) {
        return;
      }
      this.off('peer', check);
      return clearTimeout(t);
    };
    t = setTimeout(function() {
      _this.off('peer', check);
      return _this.emit('timeout', id);
    }, this.opts.wait);
    return this.on('peer', check);
  };

  LocalPeer.prototype.publish = function() {
    var peer, _i, _len, _ref, _ref1, _results;
    _ref = this.peers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      peer = _ref[_i];
      this.log("publish to " + peer.id + " (" + (typeof peer.publish) + ")");
      _results.push((_ref1 = peer.publish) != null ? _ref1.apply(peer, arguments) : void 0);
    }
    return _results;
  };

  LocalPeer.prototype.subscribe = function(event, fn) {
    var peer, _i, _len, _ref, _results;
    this.pubsub.on(event, fn);
    _ref = this.peers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      peer = _ref[_i];
      _results.push(typeof peer.subscribe === "function" ? peer.subscribe(event) : void 0);
    }
    return _results;
  };

  return LocalPeer;

})(Base);

/*
//@ sourceMappingURL=local-peer.map
*/
