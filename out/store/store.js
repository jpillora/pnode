// Generated by CoffeeScript 1.6.3
var Client, LocalPeer, Logger, Server, Store, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Logger = require('../logger');

_ = require('../../vendor/lodash');

Server = require('../server/server');

Client = require('../client/client');

LocalPeer = require('../peer/local-peer');

module.exports = Store = (function(_super) {
  __extends(Store, _super);

  Store.prototype.name = 'Store';

  Store.prototype.defaults = {
    id: null,
    debug: false,
    read: false,
    write: false,
    filter: null
  };

  function Store(peer, opts) {
    var _this = this;
    this.peer = peer;
    if (opts == null) {
      opts = {};
    }
    this.opts = _.defaults(opts, this.defaults);
    this.name = "@name(" + this.peer.id + ")";
    if (!(this.opts.id && typeof this.opts.id === "string")) {
      this.error("must have a store 'id'");
    }
    if (!(this.opts.read || this.opts.write)) {
      this.error("must 'read' or 'write'");
    }
    this.on('set', this.emit.bind(this, 'change', 'set'));
    this.on('del', this.emit.bind(this, 'change', 'del'));
    this.on('change', function(action, path, val) {
      return _this.log("pnode-store: %s: '%s': %s", action, path, val);
    });
    this.channel = "_store-" + this.opts.id;
    this.obj = {};
    if (this.opts.read) {
      this.$setupRead();
    }
    if (this.opts.write) {
      this.$setupWrite();
    }
    return;
  }

  Store.prototype.$setupRead = function() {
    var preload, preloads, self,
      _this = this;
    preloads = [];
    preload = function(remote) {
      var obj, _ref;
      obj = (_ref = remote._store) != null ? _ref[opts.name] : void 0;
      if (typeof obj !== 'object') {
        return;
      }
      if (preloads.indexOf(obj) >= 0) {
        return;
      }
      preloads.push(obj);
      _this.set([], obj, true);
    };
    self = this;
    this.peer.subscribe(this.channel, function(path, doDelete, value) {
      if (doDelete) {
        value = void 0;
      }
      if (!self.opts.filter || self.opts.filter.call(this, path, value)) {
        self.set(path, value, true);
      }
    });
    if (this.peer instanceof Client) {
      this.peer.server(preload);
    } else if (this.peer instanceof Server || this.peer instanceof LocalPeer) {
      this.peer.all(function(remotes) {
        return remotes.forEach(preload);
      });
    }
    return this.peer.on('remote', preload);
  };

  Store.prototype.$setupWrite = function() {
    var exposed,
      _this = this;
    exposed = {};
    exposed[opts.id] = [
      function() {
        return _this.obj;
      }
    ];
    return this.peer.expose({
      _store: exposed
    });
  };

  Store.prototype.object = function() {
    return this.obj;
  };

  Store.prototype.get = function(path) {
    var o;
    o = this.obj;
    while (o && path.length) {
      o = o[path.shift()];
    }
    return o;
  };

  Store.prototype.set = function(path, value, silent) {
    var k, v;
    if (typeof path === 'string') {
      path = [path];
    }
    if (!(path instanceof Array)) {
      throw new Error("set(path, ...) path must be a string or an array");
    }
    if (path.length === 0) {
      if (typeof value === 'object') {
        for (k in value) {
          v = value[k];
          this.set([k], v);
        }
        return;
      } else {
        throw new Error("set(path, ...) path empty");
      }
    }
    return this.setAcc(this.obj, [], path, value, silent);
  };

  Store.prototype.setAcc = function(obj, used, path, value, silent) {
    var doDelete, prev, prop;
    prop = path.shift();
    if (typeof prop) {
      throw new Error("property missing '" + prop + "' (typeof)");
    }
    used.push(prop);
    if (path.length > 0 && typeof obj[prop] === 'object') {
      return this.setAcc(obj[prop], used, path, value, silent);
    }
    doDelete = value === void 0;
    prev = obj[prop];
    if (_.isEqual(prev, value)) {
      return;
    }
    if (doDelete) {
      delete obj[prop];
    } else {
      obj[prop] = value;
    }
    if (!silent && this.opts.write) {
      this.peer.publish(this.channel, used, doDelete, value);
    }
    return this.emit((doDelete ? 'del' : 'set'), used, value, prev);
  };

  Store.prototype.del = function(path) {
    return this.set(path);
  };

  return Store;

})(Logger);

/*
//@ sourceMappingURL=store.map
*/
