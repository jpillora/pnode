// Generated by CoffeeScript 1.6.3
var Client, LocalPeer, Logger, Server, Store, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Logger = require('../logger');

_ = require('../../vendor/lodash');

Server = require('../server/server');

Client = require('../client/client');

LocalPeer = require('../peer/local-peer');

module.exports = Store = (function(_super) {
  __extends(Store, _super);

  Store.prototype.name = 'Store';

  Store.prototype.defaults = {
    id: null,
    debug: false,
    subscribe: false,
    publish: false,
    publishInterval: "nextTick",
    filter: null,
    eventWildcard: "*"
  };

  function Store(peer, opts) {
    var enumify,
      _this = this;
    this.peer = peer;
    if (opts == null) {
      opts = {};
    }
    this.opts = _.defaults(opts, this.defaults);
    this.name = "" + this.name + "(" + this.peer.id + ")";
    if (!(this.opts.id && typeof this.opts.id === "string")) {
      this.err("must have a store 'id'");
    }
    this.id = this.opts.id;
    if (!(this.opts.subscribe || this.opts.publish)) {
      this.err("must 'subscribe' and/or 'publish'");
    }
    enumify = function(prop) {
      var obj;
      if (_this.opts[prop]) {
        if (_this.opts[prop] instanceof Array) {
          obj = {};
          _this.opts[prop].forEach(function(k) {
            return obj[k] = true;
          });
          return _this.opts[prop] = obj;
        } else if (_this.opts[prop] !== true) {
          return _this.err("'" + prop + "' must be boolean or an array");
        }
      }
    };
    enumify('subscribe');
    enumify('publish');
    this.channel = "_store-" + this.id;
    this.obj = {};
    this.events = {};
    if (this.opts.publish) {
      this.$setupPublish();
    }
    if (this.opts.subscribe) {
      this.$setupSubscribe();
    }
    return;
  }

  Store.prototype.destroy = function() {
    var e;
    if (this.opts.publish) {
      e = {};
      e[this.opts.id] = undefined;
      this.peer.expose(e);
    }
    if (this.opts.subscribe) {
      this.peer.unsubscribe(this.channel);
      this.peer.off('remote', this.preload);
    }
  };

  Store.prototype.$setupPublish = function() {
    var exposed,
      _this = this;
    this.log("setup publish...");
    if (!(this.opts.publishInterval === "nextTick" || this.opts.publishInterval >= 0)) {
      this.err("invalid 'publishInterval' option");
    }
    this.publishId = 1;
    this.publishQue = [];
    exposed = {};
    exposed[this.opts.id] = [
      function() {
        var k, o, v, _ref;
        if (_this.opts.publish === true) {
          return _this.obj;
        }
        o = {};
        _ref = _this.obj;
        for (k in _ref) {
          v = _ref[k];
          if (_this.opts.publish[k]) {
            o[k] = v;
          }
        }
        return o;
      }
    ];
    return this.peer.expose({
      _store: exposed
    });
  };

  Store.prototype.$setupSubscribe = function() {
    var check, preloads, self,
      _this = this;
    this.log("setup subscribe...");
    check = function(path, val, ctx) {
      return (_this.opts.subscribe === true || _this.opts.subscribe[path[0]]) && (!_this.opts.filter || _this.opts.filter.call(ctx, path, value));
    };
    preloads = [];
    this.preload = function(remote) {
      var k, obj, v, _ref;
      obj = (_ref = remote._store) != null ? _ref[_this.opts.id] : void 0;
      if (typeof obj !== 'object') {
        return;
      }
      if (preloads.indexOf(obj) >= 0) {
        return;
      }
      preloads.push(obj);
      _this.log("preloading %j", obj);
      for (k in obj) {
        v = obj[k];
        k = [k];
        if (check(k, v)) {
          _this.set(k, v, true);
        }
      }
    };
    self = this;
    this.peer.subscribe(this.channel, function(updates) {
      var ctx, path, update, value, _i, _len;
      ctx = this;
      self.log("subscriptions-in #%s", updates.length);
      for (_i = 0, _len = updates.length; _i < _len; _i++) {
        update = updates[_i];
        path = update[0], value = update[1];
        if (check(path, value)) {
          self.log("subscription-in %j = %j", path, value);
          self.set(path, value, true);
        }
      }
    });
    if (this.peer instanceof Client) {
      this.peer.server(this.preload);
    } else if (this.peer instanceof Server || this.peer instanceof LocalPeer) {
      this.peer.all(function(remotes) {
        return remotes.forEach(_this.preload);
      });
    }
    return this.peer.on('remote', this.preload);
  };

  Store.prototype.object = function() {
    return this.obj;
  };

  Store.prototype.get = function(path) {
    var i, o;
    o = this.obj;
    if (typeof path === 'string') {
      return o[path];
    }
    i = 0;
    while (o && i < path.length) {
      o = o[path[i++]];
    }
    return o;
  };

  Store.prototype.del = function(path) {
    return this.set(path);
  };

  Store.prototype.set = function(path, value, silent) {
    var k, v;
    value = _.cloneDeep(value);
    if (typeof path === 'string') {
      path = [path];
    }
    if (!(path instanceof Array)) {
      this.err("set(path, ...) path must be a string or an array");
    }
    if (path.length === 0) {
      if (typeof value === 'object') {
        for (k in value) {
          v = value[k];
          this.set([k], v, silent);
        }
        return;
      } else {
        this.err("set(path, ...) path empty");
      }
    }
    return this.$set(this.obj, 0, path, value, silent);
  };

  Store.prototype.$set = function(obj, i, path, value, silent) {
    var del, k, prev, prop, t, update, v;
    prop = path[i];
    t = typeof prop;
    if (!(t === "string" || t === "number")) {
      this.err("property missing '" + prop + "' (" + t + ")");
    }
    i++;
    if (i < path.length) {
      if (typeof obj[prop] !== 'object') {
        obj[prop] = /\D/.test(path[i]) ? {} : [];
      }
      return this.$set(obj[prop], i, path, value, silent);
    }
    if (_.isPlainObject(value) && _.isPlainObject(obj[prop])) {
      for (k in value) {
        v = value[k];
        this.$set(obj[prop], i, path.concat(k), v, silent);
      }
      return;
    }
    prev = obj[prop];
    if (_.isEqual(prev, value)) {
      return;
    }
    del = value === undefined;
    if (del) {
      delete obj[prop];
    } else {
      obj[prop] = value;
    }
    if (!silent && this.opts.publish === true || this.opts.publish[path[0]]) {
      this.$publish(del ? [path] : [path, _.cloneDeep(value)]);
    }
    this.emit("change", path, value);
    update = this.$wrap(path, del ? prev : value);
    this.$emit(this.events, [], del, this.obj, update, prev);
  };

  Store.prototype.$emit = function(e, wilds, del, curr, update, prev) {
    var action, args, eObj, k, vk, w;
    if (!e) {
      return;
    }
    eObj = e.$event;
    if (eObj) {
      action = _.isPlainObject(curr) ? curr !== update ? "update" : del ? "remove" : "add" : prev === undefined ? "add" : del || curr === undefined ? "remove" : "update";
      args = wilds.slice(0);
      args.push(!curr && action === "remove" ? prev : curr);
      if (eObj[action]) {
        this.emit.apply(this, [eObj[action]].concat(args));
      }
      if (eObj["*"]) {
        this.emit.apply(this, [eObj["*"], action].concat(args));
      }
    }
    if (typeof update !== 'object') {
      return;
    }
    w = this.opts.eventWildcard;
    if (!curr) {
      curr = update;
    }
    for (k in e) {
      if (k === "$event") {
        continue;
      }
      if (k === w) {
        for (vk in update) {
          this.$emit(e[w], wilds.concat(vk), del, curr[vk], update[vk], prev);
        }
      } else if (k in update) {
        this.$emit(e[k], wilds, del, curr[k], update[k], prev);
      }
    }
  };

  Store.prototype.$publish = function(arr) {
    var fire,
      _this = this;
    this.publishQue.push(arr);
    if (this.publishQue.length !== 1) {
      return;
    }
    fire = function() {
      _this.log("publish #%s", _this.publishQue.length);
      _this.peer.publish(_this.channel, _this.publishQue);
      return _this.publishQue = [];
    };
    if (this.opts.publishInterval === "nextTick") {
      return process.nextTick(fire);
    } else {
      return setTimeout(fire, this.opts.publishInterval);
    }
  };

  Store.prototype.check = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (!(path instanceof Array)) {
      this.err("invalid path");
    }
    return path;
  };

  Store.prototype.on = function(action, path, fn) {
    var $e, e, i, p, _i, _len;
    if (arguments.length === 2) {
      fn = path;
      path = action;
      action = "*";
      if (path === "change") {
        return Store.__super__.on.call(this, "change", fn);
      }
    } else if (action !== "add" && action !== "remove" && action !== "update") {
      this.err("invalid action");
    }
    path = this.check(path);
    e = this.events;
    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
      p = path[i];
      e = e[p] || (e[p] = {});
    }
    $e = e.$event != null ? e.$event : e.$event = {};
    $e[action] = "" + action + "|" + (JSON.stringify(path));
    return Store.__super__.on.call(this, $e[action], fn);
  };

  Store.prototype.$wrap = function(path, value) {
    var i, l, root, v, _i, _ref;
    root = v = {};
    l = path.length - 1;
    for (i = _i = 0, _ref = l - 1; _i <= _ref; i = _i += 1) {
      v = v[path[i]] = {};
    }
    v[path[l]] = value;
    return root;
  };

  return Store;

})(Logger);

/*
//@ sourceMappingURL=store.map
*/
