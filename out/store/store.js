// Generated by CoffeeScript 1.6.3
var Client, LocalPeer, Logger, Server, Store, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Logger = require('../logger');

_ = require('../../vendor/lodash');

Server = require('../server/server');

Client = require('../client/client');

LocalPeer = require('../peer/local-peer');

module.exports = Store = (function(_super) {
  __extends(Store, _super);

  Store.prototype.name = 'Store';

  Store.prototype.defaults = {
    id: null,
    debug: false,
    subscribe: false,
    publish: false,
    filter: null,
    eventWildcard: "*"
  };

  function Store(peer, opts) {
    var enumify,
      _this = this;
    this.peer = peer;
    if (opts == null) {
      opts = {};
    }
    this.opts = _.defaults(opts, this.defaults);
    this.name = "" + this.name + "(" + this.peer.id + ")";
    if (!(this.opts.id && typeof this.opts.id === "string")) {
      this.err("must have a store 'id'");
    }
    this.id = this.opts.id;
    if (!(this.opts.subscribe || this.opts.publish)) {
      this.err("must 'subscribe' or 'publish'");
    }
    enumify = function(prop) {
      var obj;
      if (_this.opts[prop]) {
        if (_this.opts[prop] instanceof Array) {
          obj = {};
          _this.opts[prop].forEach(function(k) {
            return obj[k] = true;
          });
          return _this.opts[prop] = obj;
        } else if (_this.opts[prop] !== true) {
          return _this.err("'" + prop + "' must be boolean or an array");
        }
      }
    };
    enumify('subscribe');
    enumify('publish');
    this.on('change', function(action, path, val) {
      return _this.log(">>> %s: %j = %j", action, path, val);
    });
    this.channel = "_store-" + this.id;
    this.obj = {};
    this.events = {};
    if (this.opts.publish) {
      this.$setupWrite();
    }
    if (this.opts.subscribe) {
      this.$setupRead();
    }
    return;
  }

  Store.prototype.$setupWrite = function() {
    var exposed,
      _this = this;
    this.log("setup publish...");
    this.publishId = 1;
    this.publishQue = [];
    exposed = {};
    exposed[this.opts.id] = [
      function() {
        var k, o, v, _ref;
        if (_this.opts.publish === true) {
          return _this.obj;
        }
        o = {};
        _ref = _this.obj;
        for (k in _ref) {
          v = _ref[k];
          if (_this.opts.publish[k]) {
            o[k] = v;
          }
        }
        return o;
      }
    ];
    return this.peer.expose({
      _store: exposed
    });
  };

  Store.prototype.$setupRead = function() {
    var check, preload, preloads, self,
      _this = this;
    this.log("setup subscribe...");
    check = function(path, val, ctx) {
      return (_this.opts.subscribe === true || _this.opts.subscribe[path[0]]) && (!_this.opts.filter || _this.opts.filter.call(ctx, path, value));
    };
    preloads = [];
    preload = function(remote) {
      var k, obj, v, _ref;
      obj = (_ref = remote._store) != null ? _ref[_this.opts.id] : void 0;
      if (typeof obj !== 'object') {
        return;
      }
      if (preloads.indexOf(obj) >= 0) {
        return;
      }
      preloads.push(obj);
      _this.log("preloading %j", obj);
      for (k in obj) {
        v = obj[k];
        k = [k];
        if (check(k, v)) {
          _this.set(k, v, true);
        }
      }
    };
    self = this;
    this.peer.subscribe(this.channel, function(updates) {
      var ctx, path, update, value, _i, _len;
      ctx = this;
      self.log("subscriptions-in #%s", updates.length);
      for (_i = 0, _len = updates.length; _i < _len; _i++) {
        update = updates[_i];
        path = update[0], value = update[1];
        if (check(path, value)) {
          self.log("subscription-in %j = %j", path, value);
          self.set(path, value, true);
        }
      }
    });
    if (this.peer instanceof Client) {
      this.peer.server(preload);
    } else if (this.peer instanceof Server || this.peer instanceof LocalPeer) {
      this.peer.all(function(remotes) {
        return remotes.forEach(preload);
      });
    }
    return this.peer.on('remote', preload);
  };

  Store.prototype.object = function() {
    return this.obj;
  };

  Store.prototype.get = function(path) {
    var i, o;
    o = this.obj;
    if (typeof path === 'string') {
      return o[path];
    }
    i = 0;
    while (o && i < path.length) {
      o = o[path[i++]];
    }
    return o;
  };

  Store.prototype.del = function(path) {
    return this.set(path);
  };

  Store.prototype.set = function(path, value, silent) {
    var k, v;
    value = _.cloneDeep(value);
    if (typeof path === 'string') {
      path = [path];
    }
    if (!(path instanceof Array)) {
      this.err("set(path, ...) path must be a string or an array");
    }
    if (path.length === 0) {
      if (typeof value === 'object') {
        for (k in value) {
          v = value[k];
          this.set([k], v, silent);
        }
        return;
      } else {
        this.err("set(path, ...) path empty");
      }
    }
    return this.$set(this.obj, 0, path, value, silent);
  };

  Store.prototype.$set = function(obj, i, path, value, silent) {
    var del, isObj, k, prev, prop, t, v,
      _this = this;
    prop = path[i];
    t = typeof prop;
    if (!(t === "string" || t === "number")) {
      this.err("property missing '" + prop + "' (" + t + ")");
    }
    i++;
    isObj = typeof obj[prop] === 'object';
    if (i < path.length) {
      if (!isObj) {
        obj[prop] = /\D/.test(path[i]) ? {} : [];
      }
      return this.$set(obj[prop], i, path, value, silent);
    }
    if (isObj && typeof value === 'object') {
      for (k in value) {
        v = value[k];
        this.$set(obj[prop], i, path.concat(k), v, silent);
      }
      return;
    }
    del = value === void 0;
    prev = obj[prop];
    if (_.isEqual(prev, value)) {
      this.log("skip. path equates: %j (%j)", path, value);
      return;
    }
    if (del) {
      delete obj[prop];
    } else {
      obj[prop] = value;
    }
    if (!silent && this.opts.publish === true || this.opts.publish[path[0]]) {
      this.log("publish %j = %j", path, value);
      if (this.publishQue.length === 0) {
        process.nextTick(function() {
          _this.peer.publish(_this.channel, _this.publishQue);
          return _this.publishQue = [];
        });
      }
      this.publishQue.push(value === undefined ? [path] : [path, value]);
    }
    this.emit(path, value);
  };

  Store.prototype.on = function(path, fn) {
    var e, i, p, _i, _len;
    if (!(path instanceof Array)) {
      return Store.__super__.on.apply(this, arguments);
    }
    if (path.length === 0) {
      this.err("path empty");
    }
    e = this.events;
    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
      p = path[i];
      e = e[p] || (e[p] = {});
    }
    return Store.__super__.on.call(this, e.$event = JSON.stringify(path), fn);
  };

  Store.prototype.emit = function(path, value) {
    if (!(path instanceof Array)) {
      return Store.__super__.emit.apply(this, arguments);
    }
    if (path.length === 0) {
      this.err("path empty");
    }
    this.$emit(this.events, [], path, 0, value);
  };

  Store.prototype.$emit = function(e, wilds, path, pi, value) {
    var k, p, v, vk, w;
    if (!e) {
      return;
    }
    if (e.$event) {
      this.emit.apply(this, [e.$event].concat(wilds).concat(value));
    }
    w = this.opts.eventWildcard;
    if (pi < path.length) {
      p = path[pi];
      if (e[w]) {
        this.$emit(e[w], wilds.concat(p), path, pi + 1, value);
      }
      if (e[p]) {
        this.$emit(e[p], wilds, path, pi + 1, value);
      }
      return;
    }
    if (typeof value === 'object') {
      for (k in e) {
        if (k === "$event") {
          continue;
        }
        if (k === w) {
          for (vk in value) {
            v = value[vk];
            this.$emit(e[w], wilds.concat(vk), path, pi, v);
          }
        } else if (k in value) {
          this.$emit(e[k], wilds, path, pi, value[k]);
        }
      }
    }
  };

  return Store;

})(Logger);

/*
//@ sourceMappingURL=store.map
*/
