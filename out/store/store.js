// Generated by CoffeeScript 1.6.3
var Client, LocalPeer, Logger, Server, Store, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Logger = require('../logger');

_ = require('../../vendor/lodash');

Server = require('../server/server');

Client = require('../client/client');

LocalPeer = require('../peer/local-peer');

module.exports = Store = (function(_super) {
  __extends(Store, _super);

  Store.prototype.name = 'Store';

  Store.prototype.defaults = {
    id: null,
    debug: false,
    read: false,
    write: false,
    filter: null
  };

  function Store(peer, opts) {
    var _this = this;
    this.peer = peer;
    if (opts == null) {
      opts = {};
    }
    this.opts = _.defaults(opts, this.defaults);
    this.name = "@name(" + this.peer.id + ")";
    if (!(this.opts.id && typeof this.opts.id === "string")) {
      this.error("must have a store 'id'");
    }
    this.id = this.opts.id;
    if (!(this.opts.read || this.opts.write)) {
      this.error("must 'read' or 'write'");
    }
    this.on('change', function(action, path, val) {
      return _this.log(">>> %s: '%s': %s", action, path, val);
    });
    this.channel = "_store-" + this.id;
    this.obj = {};
    if (this.opts.write) {
      this.$setupWrite();
    }
    if (this.opts.read) {
      this.$setupRead();
    }
    return;
  }

  Store.prototype.$setupWrite = function() {
    var exposed,
      _this = this;
    this.log("setup write...");
    exposed = {};
    exposed[this.opts.id] = [
      function() {
        return _this.obj;
      }
    ];
    return this.peer.expose({
      _store: exposed
    });
  };

  Store.prototype.$setupRead = function() {
    var preload, preloads, self,
      _this = this;
    this.log("setup read...");
    preloads = [];
    preload = function(remote) {
      var obj, _ref;
      obj = (_ref = remote._store) != null ? _ref[_this.opts.id] : void 0;
      if (typeof obj !== 'object') {
        return;
      }
      if (preloads.indexOf(obj) >= 0) {
        return;
      }
      preloads.push(obj);
      _this.log("preloading %j", obj);
      _this.set([], obj, true);
    };
    self = this;
    this.peer.subscribe(this.channel, function(path, doDelete, value) {
      if (doDelete) {
        value = void 0;
      }
      self.log("subscription-in %j = %j", path, value);
      if (!self.opts.filter || self.opts.filter.call(this, path, value)) {
        self.set(path, value, true);
      }
    });
    if (this.peer instanceof Client) {
      this.peer.server(preload);
    } else if (this.peer instanceof Server || this.peer instanceof LocalPeer) {
      this.peer.all(function(remotes) {
        return remotes.forEach(preload);
      });
    }
    return this.peer.on('remote', preload);
  };

  Store.prototype.object = function() {
    return this.obj;
  };

  Store.prototype.get = function(path) {
    var o;
    o = this.obj;
    while (o && path.length) {
      o = o[path.shift()];
    }
    return o;
  };

  Store.prototype.set = function(path, value, silent) {
    var k, v;
    if (typeof path === 'string') {
      path = [path];
    }
    if (!(path instanceof Array)) {
      throw new Error("set(path, ...) path must be a string or an array");
    }
    if (path.length === 0) {
      if (typeof value === 'object') {
        for (k in value) {
          v = value[k];
          this.set([k], v, silent);
        }
        return;
      } else {
        throw new Error("set(path, ...) path empty");
      }
    }
    return this.setAcc(this.obj, [], path, value, silent);
  };

  Store.prototype.setAcc = function(obj, used, path, value, silent) {
    var del, prev, prop, t;
    prop = path.shift();
    t = typeof prop;
    if (!(t === "string" || t === "number")) {
      throw new Error("property missing '" + prop + "' (" + t + ")");
    }
    used.push(prop);
    if (path.length > 0) {
      if (typeof obj[prop] !== 'object') {
        if (typeof path[0] === 'number') {
          obj[prop] = [];
        } else {
          obj[prop] = {};
        }
      }
      return this.setAcc(obj[prop], used, path, value, silent);
    }
    del = value === void 0;
    prev = obj[prop];
    if (_.isEqual(prev, value)) {
      return;
    }
    if (del) {
      delete obj[prop];
    } else {
      obj[prop] = value;
    }
    if (!silent && this.opts.write) {
      this.log("publish %j = %j", used, value);
      this.peer.publish(this.channel, used, del, value);
    }
    if (del) {
      this.emit('del', used, prev);
    } else {
      this.emit('set', used, value, prev);
    }
    return this.emit('change', (del ? 'del' : 'set'), used, value, prev);
  };

  Store.prototype.del = function(path) {
    return this.set(path);
  };

  return Store;

})(Logger);

/*
//@ sourceMappingURL=store.map
*/
