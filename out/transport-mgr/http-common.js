// Generated by CoffeeScript 1.6.3
var HTTPDuplex, http, https, pkg, stream, util, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('../../vendor/lodash');

pkg = require('../../package.json');

util = require('util');

http = require('http');

https = require('https');

stream = process.version.match(/^\v0\.8/) ? require('readable-stream') : require('stream');

HTTPDuplex = (function(_super) {
  __extends(HTTPDuplex, _super);

  function HTTPDuplex(type, opts) {
    var _this = this;
    if (!(this instanceof HTTPDuplex)) {
      return new HTTPDuplex(type, opts);
    }
    stream.Duplex.call(this, type, opts);
    this.res = null;
    this.http = type === 'https' ? https : http;
    this.req = this.http.request(opts);
    this.req.on("response", function(resp) {
      _this.res = resp;
      _this.emit("response", resp);
      resp.on("data", function(c) {
        console.log('READ HTTP DATA: ' + c);
        if (!_this.push(c)) {
          return _this.res.pause();
        }
      });
      return resp.on("end", function() {
        return _this.push(null);
      });
    });
  }

  HTTPDuplex.prototype._read = function(n) {
    if (this.res) {
      return this.res.resume();
    }
  };

  HTTPDuplex.prototype._write = function(chunk, encoding, cb) {
    console.log('WRITE HTTP DATA: ' + chunk);
    return this.req.write(chunk, encoding, cb);
  };

  HTTPDuplex.prototype.end = function(chunk, encoding, cb) {
    console.log('HTTP END');
    return this.req.end(chunk, encoding, cb);
  };

  return HTTPDuplex;

})(stream.Duplex);

exports.createServer = function(callback, pserver, type, listenArgs, serverArgs) {
  var hostname, httpModule, port, s;
  httpModule = require(type);
  s = httpModule.createServer.apply(null, serverArgs);
  s.listen.apply(s, listenArgs);
  hostname = typeof listenArgs[1] === 'string' ? listenArgs[1] : '0.0.0.0';
  port = listenArgs[0];
  s.once('listening', function() {
    return callback({
      uri: "" + type + "://" + hostname + ":" + port,
      unbind: function(cb) {
        return s.close(cb);
      }
    });
  });
};

exports.createClient = function(pclient, type, reqArgs, extraOpts) {
  var opts, uri;
  if (extraOpts == null) {
    extraOpts = {};
  }
  opts = {
    path: '/' + pkg.name,
    headers: {
      'user-agent': pkg.name + '/' + pkg.version,
      'transfer-encoding': 'chunked',
      'expect': '100-continue'
    }
  };
  _.merge(opts, extraOpts);
  if (typeof reqArgs[0] === 'number') {
    opts.port = reqArgs.shift();
  } else {
    pclient.err("bind " + type + " error: missing port");
  }
  if (typeof reqArgs[0] === 'string') {
    opts.hostname = reqArgs.shift();
  }
  uri = "" + type + "://" + (opts.hostname || 'localhost') + ":" + opts.port;
  pclient.createConnection(function(callback) {
    stream = HTTPDuplex(type, opts);
    callback({
      uri: uri,
      stream: stream,
      unbind: function(cb) {
        stream.end();
        return cb(true);
      }
    });
  });
};

/*
//@ sourceMappingURL=http-common.map
*/
