// Generated by CoffeeScript 1.6.3
var Base, Connection, ObjectIndex, Server, dnode, helper, servers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

dnode = require('dnode');

Base = require('../base');

helper = require('../helper');

ObjectIndex = require('object-index');

Connection = require('./connection');

servers = [];

module.exports = Server = (function(_super) {
  __extends(Server, _super);

  Server.prototype.name = 'Server';

  Server.prototype.defaults = {
    debug: false,
    wait: 5000,
    timeout: 5000
  };

  function Server() {
    var _this = this;
    servers.push(this);
    Server.__super__.constructor.apply(this, arguments);
    this.connections = helper.set();
    this.bindOn = this.bind;
    this.on('unbinding', function() {
      var conn, _i, _len, _ref;
      _ref = _this.connections.copy();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        conn = _ref[_i];
        conn.unbind();
      }
    });
    this.on('uri', function(uri) {
      _this.uri = uri;
    });
    this.on('stream', this.handle);
    return;
  }

  Server.prototype.handle = function(read, write) {
    var conn,
      _this = this;
    if (read.write && !(write != null ? write.write : void 0)) {
      write = read;
    }
    if (!helper.isReadable(read)) {
      this.err(new Error("Invalid read stream"));
    }
    if (!helper.isWritable(write)) {
      this.err(new Error("Invalid write stream"));
    }
    conn = new Connection(this, read, write);
    conn.on('error', this.onError);
    conn.on('fail', this.onFail);
    conn.once('up', function() {
      _this.log("CONN UP " + conn.id);
      if (_this.connections.findAllBy('id', conn.id).length >= 2 || _this.connections.findAllBy('guid', conn.guid).length >= 2) {
        _this.warn("rejected duplicate conn with id " + conn.id + " (" + conn.guid + ")");
        conn.unbind();
        return;
      }
      conn.accepted = true;
      _this.emit('remote', conn.remote);
    });
    conn.once('down', function() {
      if (_this.connections.remove(conn)) {
        _this.emit('disconnection', conn);
      }
    });
    this.connections.add(conn);
    this.emit('connection', conn, this);
  };

  Server.prototype.onError = function(err) {
    return this.emit('error', err);
  };

  Server.prototype.onFail = function(err) {
    return this.emit('fail', err);
  };

  Server.prototype.client = function(id, callback) {
    var check, get, t,
      _this = this;
    get = function() {
      var conn;
      conn = _this.connections.findBy('id', id) || _this.connections.findBy('guid', id);
      if (!conn) {
        return false;
      }
      callback(conn.remote);
      return true;
    };
    if (get()) {
      return;
    }
    check = function() {
      if (!get()) {
        return;
      }
      this.off('remote', check);
      return clearTimeout(t);
    };
    t = setTimeout(function() {
      _this.off('remote', check);
      return _this.emit('waitout', id);
    }, this.opts.wait);
    this.on('remote', check);
  };

  Server.prototype.publish = function() {
    var args, conn, _i, _len, _ref;
    args = arguments;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      conn = _ref[_i];
      conn.publish.apply(conn, args);
    }
  };

  Server.prototype.subscribe = function(event, fn) {
    var conn, _i, _len, _ref;
    this.pubsub.on(event, fn);
    if (this.pubsub.listeners(event).length === 1) {
      _ref = this.connections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        conn = _ref[_i];
        conn.subscribe(event);
      }
    }
  };

  Server.prototype.serialize = function() {
    return this.uri;
  };

  return Server;

})(Base);

if (typeof process.on === "function") {
  process.on('exit', function() {
    var server, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = servers.length; _i < _len; _i++) {
      server = servers[_i];
      _results.push(server.unbind());
    }
    return _results;
  });
}

if (typeof process.on === "function") {
  process.on('SIGINT', function() {
    return process.exit();
  });
}

/*
//@ sourceMappingURL=server.map
*/
