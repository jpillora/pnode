// Generated by CoffeeScript 1.6.3
var Base, Client, RemoteContext, dnode, helper, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require('../../vendor/lodash');

dnode = require('dnode');

Base = require('../base');

helper = require('../helper');

RemoteContext = require('../context');

module.exports = Client = (function(_super) {
  __extends(Client, _super);

  Client.prototype.name = 'Client';

  Client.prototype.defaults = {
    debug: false,
    maxRetries: 5,
    timeout: 5000,
    retryInterval: 500,
    pingInterval: 5000,
    port: 7337
  };

  function Client() {
    var _this = this;
    Client.__super__.constructor.apply(this, arguments);
    this.stream = {};
    this.count = {
      ping: 0,
      pong: 0,
      attempt: 0
    };
    this.connecting = false;
    this.status = 'down';
    this.reconnect = this.timeoutify('reconnect', this.reconnect);
    this.reconnect = _.throttle(this.reconnect, this.opts.retryInterval, {
      leading: true
    });
    this.on(['timeout', 'reconnect'], function() {
      _this.log("reconnect TIMEOUT!");
      _this.reset();
      return _this.reconnect();
    });
    this.ping = _.throttle(this.ping, this.opts.pingInterval);
    this.on(['timeout', 'ping'], function() {
      _this.log("ping TIMEOUT!");
      return _this.setStatus('down');
    });
    this.bindTo = this.bind;
  }

  Client.prototype.createConnection = function(fn) {
    if (typeof fn !== 'function') {
      this.err("must be a function");
    }
    if (!(fn.length === 1 || fn.length === 2)) {
      this.err("must have arity 1 or 2");
    }
    this.getConnectionFn = fn;
    this.reconnect();
  };

  Client.prototype.server = function(callback) {
    if (!this.getConnectionFn) {
      return this.err("no create connection method defined");
    }
    if (this.status === 'up') {
      return callback(this.remote);
    } else if (this.status === 'down' && !this.connecting) {
      this.count.attempt = 0;
      this.reconnect();
    }
    this.once('remote', callback);
  };

  Client.prototype.unget = function(callback) {
    return this.removeListener('remote', callback);
  };

  Client.prototype.reconnect = function(callback) {
    var gotWrite, spliceRead, spliceWrite, spliced,
      _this = this;
    if (this.status === 'up' || this.connecting || this.count.attempt >= this.opts.maxRetries) {
      return;
    }
    this.count.attempt++;
    this.connecting = true;
    this.reset();
    this.ctx = new RemoteContext;
    this.d = dnode(this.wrapObject(this.exposed, this.ctx));
    this.d.once('remote', this.onRemote);
    this.d.once('end', this.onEnd);
    this.d.once('error', this.onError);
    this.d.once('fail', this.onStreamError);
    gotWrite = false;
    this.log("connection attempt " + this.count.attempt + " to " + (this.uri()) + "...");
    this.emit('connecting');
    spliceRead = function(read) {
      if (gotRead) {

      }
    };
    spliceWrite = function(write) {
      if (gotWrite) {
        return;
      }
      return _this.log("SPLICE WRITE");
    };
    spliced = false;
    this.getConnectionFn(function(obj) {
      var stream, unbind, uri;
      if (spliced) {
        return;
      }
      spliced = true;
      stream = obj.stream, unbind = obj.unbind, uri = obj.uri;
      if (typeof unbind !== 'function') {
        _this.err("unbind function missing");
      }
      if (typeof uri !== 'string') {
        _this.err("uri string missing");
      }
      if (!helper.isReadable(stream)) {
        _this.err("Invalid read stream");
      }
      if (!helper.isWritable(stream)) {
        _this.err("Invalid write stream");
      }
      _this.emit('stream', {
        unbind: unbind,
        uri: uri
      });
      stream.on('error', _this.onStreamError);
      _this.ctx.getAddr(stream);
      return stream.pipe(_this.d).pipe(stream);
    });
  };

  Client.prototype.onStreamError = function(err) {
    if (!this.isBound) {
      return;
    }
    this.log("stream error: " + err.message);
    this.setStatus('down');
    this.reconnect();
  };

  Client.prototype.onError = function(err) {
    var msg;
    if (!this.isBound) {
      return;
    }
    msg = err.stack ? err.stack + "\n====" : err;
    return this.err(msg);
  };

  Client.prototype.onRemote = function(remote) {
    var meta;
    remote = this.wrapObject(remote);
    meta = remote != null ? remote._pnode : void 0;
    if (typeof (meta != null ? meta.ping : void 0) !== "function") {
      return this.err("Invalid pnode host");
    }
    this.remote = remote;
    this.ctx.getMeta(meta);
    this.log("EMIT REMOTE", remote);
    this.emit('remote', this.remote, this);
    this.setStatus('up');
    return this.ping();
  };

  Client.prototype.ping = function() {
    var _this = this;
    if (this.status === 'down') {
      return;
    }
    this.count.ping++;
    return this.remote._pnode.ping(function(ok) {
      if (ok === true) {
        _this.count.pong++;
      }
      return _this.ping();
    });
  };

  Client.prototype.onEnd = function() {
    this.log("server closed connection");
    this.setStatus('down');
    return this.reconnect();
  };

  Client.prototype.setStatus = function(s) {
    this.connecting = false;
    if (!((s === 'up' || s === 'down') && s !== this.status)) {
      return;
    }
    this.log(s);
    this.status = s;
    return this.emit(s);
  };

  Client.prototype.reset = function() {
    this.setStatus('down');
    if (this.d) {
      this.d.removeAllListeners().end();
      return this.d = null;
    }
  };

  Client.prototype.publish = function() {
    var args,
      _this = this;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.server(function(remote) {
      var event;
      event = typeof args[0] === 'function' ? args[1] : args[0];
      if (!_this.ctx.events[event]) {
        _this.log("server " + _this.ctx.id + " isnt subscribed to " + event);
        return;
      }
      _this.log("publishing a " + event);
      return remote._pnode.publish.apply(null, args);
    });
  };

  Client.prototype.subscribe = function(event, fn) {
    var _this = this;
    this.pubsub.on(event, fn);
    if (!this.getConnectionFn) {
      return;
    }
    if (this.pubsub.listeners(event).length === 1) {
      this.server(function(remote) {
        return remote._pnode.subscribe(event);
      });
    }
  };

  Client.prototype.serialize = function() {
    return this.uri();
  };

  return Client;

})(Base);

/*
//@ sourceMappingURL=client.map
*/
